import { isNullOrUndefined, extend } from '@syncfusion/ej2-base';
import { Query, DataManager, Predicate } from '@syncfusion/ej2-data';
import { getRecurrenceStringFromDate, generate, getDateFromRecurrenceDateString } from '../../recurrence-editor/date-generator';
import * as events from '../base/constant';
import { Timezone } from '../timezone/timezone';
/**
 * Schedule CRUD operations
 */
var Crud = /** @class */ (function () {
    function Crud(parent) {
        this.parent = parent;
        this.timezone = new Timezone();
    }
    Crud.prototype.getQuery = function () {
        var start = this.parent.activeView.startDate();
        var end = this.parent.activeView.endDate();
        return this.parent.dataModule.generateQuery(start, end);
    };
    Crud.prototype.getTable = function () {
        if (this.parent.eventSettings.query) {
            var query = this.parent.eventSettings.query.clone();
            return query.fromTable;
        }
        return null;
    };
    Crud.prototype.refreshData = function (args) {
        var _this = this;
        var actionArgs = { requestType: args.requestType, cancel: false, data: args.data };
        if (this.parent.dataModule.dataManager.dataSource.offline) {
            this.parent.trigger(events.actionComplete, actionArgs);
            this.parent.renderModule.refreshDataManager();
            return;
        }
        else {
            args.promise.then(function (e) {
                if (_this.parent.isDestroyed) {
                    return;
                }
                _this.parent.trigger(events.actionComplete, actionArgs);
                if (actionArgs.cancel) {
                    return;
                }
                _this.parent.renderModule.refreshDataManager();
            }).catch(function (e) {
                if (_this.parent.isDestroyed) {
                    return;
                }
                _this.parent.trigger(events.actionFailure, { error: e });
            });
        }
    };
    Crud.prototype.addEvent = function (eventData) {
        if (this.parent.eventBase.isBlockRange(eventData)) {
            var data = (eventData instanceof Array) ? [eventData] : eventData;
            this.parent.quickPopup.openValidationError('blockAlert', data);
            return;
        }
        var fields = this.parent.eventFields;
        var promise = null;
        var editParms = { addedRecords: [], changedRecords: [], deletedRecords: [] };
        var args = {
            cancel: false,
            data: (eventData instanceof Array) ? eventData : [eventData],
            requestType: 'eventCreate'
        };
        this.parent.trigger(events.actionBegin, args);
        if (args.cancel) {
            return;
        }
        if (eventData instanceof Array) {
            for (var _i = 0, _a = eventData; _i < _a.length; _i++) {
                var event_1 = _a[_i];
                this.processCrudTimezone(event_1);
                editParms.addedRecords.push(event_1);
            }
            promise =
                this.parent.dataModule.dataManager.saveChanges(editParms, fields.id, this.getTable(), this.getQuery());
        }
        else {
            this.processCrudTimezone(eventData);
            promise = this.parent.dataModule.dataManager.insert(eventData, this.getTable(), this.getQuery());
        }
        var crudArgs = { requestType: 'eventCreated', cancel: false, data: eventData, promise: promise };
        this.refreshData(crudArgs);
    };
    Crud.prototype.saveEvent = function (event, action) {
        if (this.parent.eventBase.isBlockRange(event)) {
            var data_1 = (event instanceof Array) ? [event] : event;
            this.parent.quickPopup.openValidationError('blockAlert', data_1);
            return;
        }
        this.parent.currentAction = action;
        var fields = this.parent.eventFields;
        var promise = null;
        var editParms = { addedRecords: [], changedRecords: [], deletedRecords: [] };
        var args = { requestType: 'eventChange', cancel: false };
        var data = event;
        if (isNullOrUndefined(action)) {
            args.data = data;
            this.parent.trigger(events.actionBegin, args);
            if (args.cancel) {
                return;
            }
            this.processCrudTimezone(data);
            if ((event instanceof Array)) {
                editParms.changedRecords = event;
                this.parent.dataModule.dataManager.saveChanges(editParms, fields.id, this.getTable(), this.getQuery());
            }
            else {
                promise = this.parent.dataModule.dataManager.update(fields.id, event, this.getTable(), this.getQuery());
            }
        }
        else {
            var parentEvent = this.getParentEvent(data);
            switch (action) {
                case 'EditOccurrence':
                    var edited = this.getEditedOccurrence(data.Guid);
                    args.data = { occurrence: event, parent: parentEvent };
                    this.parent.trigger(events.actionBegin, args);
                    if (args.cancel) {
                        return;
                    }
                    var exDate = this.excludeDateCheck(edited[0][fields.startTime], parentEvent[fields.recurrenceException]);
                    if (exDate !== parentEvent[fields.recurrenceException]) {
                        parentEvent[fields.recurrenceException] = exDate;
                        data[fields.recurrenceID] = parentEvent[fields.id];
                        if (!isNullOrUndefined(data[fields.followingID])) {
                            delete (data[fields.followingID]);
                        }
                        this.processCrudTimezone(parentEvent);
                        editParms.changedRecords.push(parentEvent);
                        this.processCrudTimezone(data);
                        editParms.addedRecords.push(data);
                    }
                    else {
                        this.processCrudTimezone(data);
                        editParms.changedRecords.push(data);
                    }
                    break;
                case 'EditFollowingEvents':
                    if (!this.processEditFutureOccurence(data, parentEvent, editParms)) {
                        return;
                    }
                    break;
                case 'EditSeries':
                    if (!this.processEditSeries(data, parentEvent, editParms)) {
                        return;
                    }
                    this.parent.uiStateValues.isIgnoreOccurrence = false;
                    break;
            }
            promise =
                this.parent.dataModule.dataManager.saveChanges(editParms, fields.id, this.getTable(), this.getQuery());
        }
        // if (!this.parent.activeView.isTimelineView()) {
        //     this.parent.eventBase.selectWorkCellByTime(dataObj);
        // }
        var crudArgs = { requestType: 'eventChanged', cancel: false, data: args.data, promise: promise };
        this.refreshData(crudArgs);
    };
    Crud.prototype.processEditFutureOccurence = function (data, parentEvent, editParms) {
        var args = { requestType: 'eventChange', cancel: false };
        args.data = data;
        var edited = this.getEditedOccurrence(data.Guid);
        var fields = this.parent.eventFields;
        this.parent.trigger(events.actionBegin, args);
        if (args.cancel) {
            return false;
        }
        var isEventStart = edited[0][fields.startTime].getTime() === parentEvent[fields.startTime].getTime();
        var date;
        var immediateParentEvent;
        if (edited[0][fields.id] === parentEvent[fields.id] && isEventStart) {
            data[fields.id] = parentEvent[fields.id];
            immediateParentEvent = extend({}, parentEvent);
        }
        else {
            immediateParentEvent = extend({}, this.parent.eventBase.getEventById(edited[0][fields.id]));
        }
        var initialRecRule = immediateParentEvent[fields.recurrenceRule];
        if (data[fields.startTime] !== immediateParentEvent[fields.startTime]) {
            immediateParentEvent[fields.recurrenceRule] = this.getUpdatedParentRule(immediateParentEvent, edited[0]);
        }
        data[fields.recurrenceID] = null;
        var deleteRecurrenceEventList = [];
        var deleteFutureEditEventList = this.parent.eventBase.getSeriesEvents(immediateParentEvent, edited[0][fields.startTime]);
        if (deleteFutureEditEventList.length > 0) {
            initialRecRule = deleteFutureEditEventList.slice(-1)[0][fields.recurrenceRule];
        }
        if ((data[fields.recurrenceRule].indexOf('COUNT') > -1
            || data[fields.recurrenceRule].indexOf('UNTIL') > -1)) {
            var datecollection = generate(parentEvent[fields.startTime], initialRecRule, null, 0);
            date = datecollection[datecollection.length - 1];
        }
        deleteRecurrenceEventList = deleteRecurrenceEventList.concat(this.parent.eventBase.getEditedOccurrences(edited, edited[0][fields.startTime]));
        // To reset following id when start/end time changed or when doing following edit from 1st occurrence of the series
        if (new Date('' + data[fields.startTime]).getTime() !== new Date('' + edited[0][fields.startTime]).getTime()
            || new Date('' + data[fields.endTime]).getTime() !== new Date('' + edited[0][fields.endTime]).getTime() || isEventStart) {
            delete (data[fields.followingID]);
        }
        // To update recurrencce exception 
        data[fields.recurrenceException] = this.parent.uiStateValues.isIgnoreOccurrence
            ? this.updateRecurrenceException(deleteFutureEditEventList, data, parentEvent) : null;
        // To get the update recurrence rule
        data = this.updateRecurrenceRule(deleteFutureEditEventList, data, date);
        if (!isEventStart) {
            this.processCrudTimezone(immediateParentEvent);
            editParms.changedRecords.push(immediateParentEvent);
            this.processCrudTimezone(data);
            editParms.addedRecords.push(data);
        }
        else {
            this.processCrudTimezone(data);
            editParms.changedRecords.push(data);
        }
        if (!this.parent.uiStateValues.isIgnoreOccurrence) {
            this.updateParentRecurrentException(immediateParentEvent, edited[0], editParms);
            deleteRecurrenceEventList = deleteRecurrenceEventList.concat(this.parent.eventBase.getEditedOccurrences(deleteFutureEditEventList, edited[0][fields.startTime]));
            editParms.deletedRecords = editParms.deletedRecords.concat(deleteRecurrenceEventList);
        }
        else {
            // to delete the existing events when edit events using following events
            var deleteFutureEditEvents = new Predicate(fields.recurrenceID, 'equal', null);
            deleteFutureEditEventList = this.parent.eventBase.getFilterEventsList(deleteFutureEditEventList, deleteFutureEditEvents);
        }
        // to update the edited event recurrence id & recurrence exception when delele the events
        this.updateRecurrenceIdAfterFollowingSeriesEdit(data, deleteRecurrenceEventList, edited[0], editParms);
        // To delete the existing events after updating futuer edit series.
        editParms.deletedRecords = editParms.deletedRecords.concat(deleteFutureEditEventList);
        this.parent.uiStateValues.isIgnoreOccurrence = false;
        return true;
    };
    Crud.prototype.processEditSeries = function (data, parentEvent, editParms) {
        var args = { requestType: 'eventChange', cancel: false };
        var fields = this.parent.eventFields;
        args.data = data;
        this.parent.trigger(events.actionBegin, args);
        if (args.cancel) {
            return false;
        }
        if (!this.parent.eventSettings.editFollowingEvents) {
            this.editSeries(data, parentEvent, editParms);
            return true;
        }
        var deleteRecurrenceEventList = [];
        var deleteExistingEvents = this.parent.eventBase.getSeriesEvents(parentEvent);
        if (deleteExistingEvents.length === 0) {
            this.editSeries(data, parentEvent, editParms);
            return true;
        }
        else {
            if (data[fields.recurrenceRule] === parentEvent[fields.recurrenceRule]) {
                data[fields.recurrenceRule] = deleteExistingEvents.slice(-1)[0][fields.recurrenceRule];
            }
            deleteRecurrenceEventList = this.parent.eventBase.getEditedOccurrences(deleteExistingEvents);
            data[fields.recurrenceException] = this.parent.uiStateValues.isIgnoreOccurrence
                ? this.updateRecurrenceException(deleteRecurrenceEventList, data, parentEvent) : null;
        }
        data[fields.id] = parentEvent[fields.id];
        data[fields.recurrenceID] = null;
        if (!isNullOrUndefined(data[fields.followingID])) {
            delete (data[fields.followingID]);
        }
        this.processCrudTimezone(data);
        editParms.changedRecords.push(data);
        // to update the edited event recurrence id & recurrence exception when delele the events
        this.updateRecurrenceIdAfterFollowingSeriesEdit(data, deleteRecurrenceEventList, parentEvent, editParms);
        if (!this.parent.uiStateValues.isIgnoreOccurrence) {
            editParms.deletedRecords = editParms.deletedRecords.concat(deleteRecurrenceEventList);
        }
        for (var _i = 0, deleteExistingEvents_1 = deleteExistingEvents; _i < deleteExistingEvents_1.length; _i++) {
            var event_2 = deleteExistingEvents_1[_i];
            if (data[fields.id] !== event_2[fields.id]) {
                editParms.deletedRecords.push(event_2);
            }
        }
        return true;
    };
    Crud.prototype.editSeries = function (data, parentEvent, editParms) {
        var fields = this.parent.eventFields;
        var query = new Query().where(fields.recurrenceID, 'equal', parentEvent[fields.id]);
        var delApp = new DataManager(this.parent.eventsData).executeLocal(query);
        data[fields.id] = parentEvent[fields.id];
        data[fields.recurrenceException] = this.parent.uiStateValues.isIgnoreOccurrence ?
            parentEvent[fields.recurrenceException] : null;
        data[fields.recurrenceID] = null;
        this.processCrudTimezone(data);
        editParms.changedRecords.push(data);
        if (!this.parent.uiStateValues.isIgnoreOccurrence) {
            for (var _i = 0, delApp_1 = delApp; _i < delApp_1.length; _i++) {
                var event_3 = delApp_1[_i];
                editParms.deletedRecords.push(event_3);
            }
        }
    };
    Crud.prototype.updateRecurrenceIdAfterFollowingSeriesEdit = function (data, eventsList, edited, editParms) {
        var fields = this.parent.eventFields;
        var updateRecurrenceId = (new Predicate(fields.recurrenceID, 'notequal', null)).
            and(new Predicate(fields.startTime, 'greaterthanorequal', edited[fields.startTime]));
        var eventsToUpdateRecurrenceId = this.parent.eventBase.getFilterEventsList(eventsList, updateRecurrenceId);
        for (var _i = 0, eventsToUpdateRecurrenceId_1 = eventsToUpdateRecurrenceId; _i < eventsToUpdateRecurrenceId_1.length; _i++) {
            var event_4 = eventsToUpdateRecurrenceId_1[_i];
            event_4[fields.recurrenceID] = data[fields.id];
            event_4[fields.recurrenceException] = data[fields.recurrenceException];
            event_4[fields.followingID] = null;
            editParms.changedRecords.push(event_4);
        }
    };
    Crud.prototype.updateRecurrenceRule = function (followingEventsList, data, lastEventDate) {
        var fields = this.parent.eventFields;
        if (followingEventsList.length > 0) {
            data[fields.recurrenceRule] = followingEventsList.slice(-1)[0][fields.recurrenceRule];
        }
        if (!isNullOrUndefined(lastEventDate) && (data[fields.recurrenceRule].indexOf('COUNT') > -1
            || data[fields.recurrenceRule].indexOf('UNTIL') > -1)) {
            var date = new Date(lastEventDate);
            var startTime = new Date(date.setDate((new Date(lastEventDate)).getDate()));
            data[fields.recurrenceRule] = this.formatRecurrenceRule(data, startTime);
        }
        return data;
    };
    Crud.prototype.updateRecurrenceException = function (ignoreFutureEventList, data, parentEvent) {
        var fields = this.parent.eventFields;
        for (var _i = 0, ignoreFutureEventList_1 = ignoreFutureEventList; _i < ignoreFutureEventList_1.length; _i++) {
            var event_5 = ignoreFutureEventList_1[_i];
            if (isNullOrUndefined(event_5[fields.recurrenceException])) {
                var followingEvent = new Predicate(fields.id, 'equal', event_5[fields.recurrenceID]);
                var recParentEvent = this.parent.eventBase.getFilterEventsList(this.parent.eventsData, followingEvent);
                event_5[fields.recurrenceException] = recParentEvent.length > 0 ?
                    recParentEvent[0][fields.recurrenceException] : event_5[fields.recurrenceException];
            }
            if (!isNullOrUndefined(data[fields.recurrenceException]) && !isNullOrUndefined(event_5[fields.recurrenceException]) &&
                data[fields.recurrenceException].indexOf(event_5[fields.recurrenceException]) === -1) {
                data[fields.recurrenceException] = data[fields.recurrenceException] + ',' + event_5[fields.recurrenceException];
            }
            else if (isNullOrUndefined(data[fields.recurrenceException])) {
                data[fields.recurrenceException] = !isNullOrUndefined(parentEvent[fields.recurrenceException])
                    ? parentEvent[fields.recurrenceException] : event_5[fields.recurrenceException];
            }
        }
        return data[fields.recurrenceException];
    };
    Crud.prototype.updateParentRecurrentException = function (parentEvent, edited, editParms) {
        var fields = this.parent.eventFields;
        var recurrenceString = isNullOrUndefined(parentEvent[fields.recurrenceException])
            ? [] : parentEvent[fields.recurrenceException].split(',');
        var flag = 0;
        var parentExceptionUpdated = false;
        for (var _i = 0, recurrenceString_1 = recurrenceString; _i < recurrenceString_1.length; _i++) {
            var recucrrence = recurrenceString_1[_i];
            flag++;
            var recurrenceDate = getDateFromRecurrenceDateString(recucrrence);
            if (recurrenceDate >= edited[fields.startTime]) {
                var replaceString = flag > 1 ? ',' + recucrrence : recucrrence;
                parentEvent[fields.recurrenceException] = parentEvent[fields.recurrenceException]
                    .replace(replaceString, '');
                parentEvent[fields.recurrenceException] = parentEvent[fields.recurrenceException] === '' ? null
                    : parentEvent[fields.recurrenceException];
                parentExceptionUpdated = true;
            }
        }
        if (parentExceptionUpdated) {
            editParms.changedRecords.push(parentEvent);
        }
    };
    Crud.prototype.deleteEvent = function (id, action) {
        var fields = this.parent.eventFields;
        var editParms = { addedRecords: [], changedRecords: [], deletedRecords: [] };
        var dataObj = [];
        var normalEvent = [];
        var recEvent = [];
        this.parent.currentAction = action;
        switch (typeof id) {
            case 'string':
            case 'number':
                dataObj = new DataManager(this.parent.eventsData).executeLocal(new Query().where(fields.id, 'equal', id));
                break;
            case 'object':
                dataObj = (id instanceof Array) ? id : [id];
                break;
        }
        for (var _i = 0, _a = dataObj; _i < _a.length; _i++) {
            var event_6 = _a[_i];
            (!isNullOrUndefined(event_6[fields.recurrenceRule])) ? recEvent.push(event_6) : normalEvent.push(event_6);
        }
        var args = { requestType: 'eventRemove', cancel: false };
        if (action !== 'DeleteOccurrence') {
            args.data = dataObj;
            this.parent.trigger(events.actionBegin, args);
            if (args.cancel) {
                return;
            }
        }
        if (isNullOrUndefined(action) || normalEvent.length > 0) {
            for (var _b = 0, normalEvent_1 = normalEvent; _b < normalEvent_1.length; _b++) {
                var event_7 = normalEvent_1[_b];
                editParms.deletedRecords.push(event_7);
            }
        }
        if (recEvent.length > 0) {
            switch (action) {
                case 'Delete':
                case 'DeleteOccurrence':
                    for (var i = 0; i < recEvent.length; i++) {
                        var parentEvent = this.getParentEvent(recEvent[i]);
                        args.data = { occurrence: recEvent[i], parent: parentEvent };
                        this.parent.trigger(events.actionBegin, args);
                        if (args.cancel) {
                            return;
                        }
                        parentEvent[fields.recurrenceException] =
                            this.excludeDateCheck(recEvent[i][fields.startTime], parentEvent[fields.recurrenceException]);
                        this.processCrudTimezone(parentEvent);
                        editParms.changedRecords.push(parentEvent);
                        if (recEvent[i][fields.id] !== parentEvent[fields.id]) {
                            editParms.deletedRecords.push(recEvent[i]);
                        }
                    }
                    break;
                case 'DeleteFollowingEvents':
                case 'DeleteSeries':
                    if (!this.parent.eventSettings.editFollowingEvents) {
                        for (var _c = 0, recEvent_1 = recEvent; _c < recEvent_1.length; _c++) {
                            var app = recEvent_1[_c];
                            var predicate = new Predicate(fields.id, 'equal', (app[fields.recurrenceID] || id)).
                                or(new Predicate(fields.recurrenceID, 'equal', (app[fields.recurrenceID] || id)));
                            var delApp = new DataManager(this.parent.eventsData).executeLocal(new Query().where(predicate));
                            for (var _d = 0, delApp_2 = delApp; _d < delApp_2.length; _d++) {
                                var event_8 = delApp_2[_d];
                                editParms.deletedRecords.push(event_8);
                            }
                        }
                    }
                    else {
                        editParms = this.processDeleteSeries(recEvent, editParms, id);
                    }
                    break;
            }
        }
        var promise;
        if (editParms.deletedRecords.length === 1 && editParms.changedRecords.length === 0) {
            var deleteEvent = editParms.deletedRecords[0];
            promise =
                this.parent.dataModule.dataManager.remove(fields.id, deleteEvent, this.getTable(), this.getQuery());
        }
        else {
            promise =
                this.parent.dataModule.dataManager.saveChanges(editParms, fields.id, this.getTable(), this.getQuery());
        }
        this.parent.eventBase.selectWorkCellByTime(dataObj);
        var crudArgs = { requestType: 'eventRemoved', cancel: false, data: args.data, promise: promise };
        this.refreshData(crudArgs);
    };
    Crud.prototype.processDeleteSeries = function (recEvent, editParms, id) {
        var fields = this.parent.eventFields;
        for (var _i = 0, recEvent_2 = recEvent; _i < recEvent_2.length; _i++) {
            var app = recEvent_2[_i];
            // To set recurrenceID when directly call deleteEvent, Since the parent event is taken based on recucrrence id.
            app[fields.recurrenceID] = isNullOrUndefined(app[fields.recurrenceID]) ? app[fields.id] : app[fields.recurrenceID];
            var parentEvent = void 0;
            var followingEvents = [];
            var delApp = void 0;
            var eventID = void 0;
            var recurrenceEvent = void 0;
            if (this.parent.currentAction === 'DeleteFollowingEvents') {
                parentEvent = this.parent.eventBase.getRecurrenceEvent(app);
                eventID = app[fields.id];
                // To update until date for every future delete occurences 
                parentEvent[fields.recurrenceRule] = this.getUpdatedParentRule(parentEvent, app);
                this.processCrudTimezone(parentEvent);
                editParms.changedRecords = editParms.changedRecords.concat(parentEvent);
                // To ignore the past date of clicked event's from edit 
                var delEventQuery = new Predicate(fields.id, 'equal', eventID).
                    and(new Predicate(fields.startTime, 'lessthanorequal', app[fields.startTime]));
                followingEvents = this.parent.eventBase.getSeriesEvents(parentEvent, app[fields.startTime]);
                this.updateParentRecurrentException(parentEvent, app, editParms);
                var currentEvent = this.parent.eventBase.getFilterEventsList(this.parent.eventsProcessed, delEventQuery);
                if (currentEvent.length === 1) {
                    editParms.deletedRecords = editParms.deletedRecords.concat(app);
                }
                recurrenceEvent = (new Predicate(fields.recurrenceID, 'equal', eventID).and(new Predicate(fields.startTime, 'greaterthanorequal', app[fields.startTime])));
            }
            else {
                parentEvent = this.getParentEvent(app);
                eventID = parentEvent[fields.id];
                followingEvents = this.parent.eventBase.getSeriesEvents(parentEvent);
                editParms.deletedRecords = editParms.deletedRecords.concat(parentEvent);
                recurrenceEvent = (new Predicate(fields.recurrenceID, 'equal', eventID));
            }
            if (followingEvents.length === 0) {
                delApp = this.parent.eventBase.getFilterEventsList(this.parent.eventsData, recurrenceEvent);
            }
            else {
                delApp = followingEvents.concat(this.parent.eventBase.getEditedOccurrences(followingEvents, parentEvent[fields.startTime]));
            }
            editParms.deletedRecords = editParms.deletedRecords.concat(delApp);
        }
        return editParms;
    };
    Crud.prototype.getParentEvent = function (event) {
        var fields = this.parent.eventFields;
        var parentEvent;
        if (this.parent.eventSettings.editFollowingEvents && (!isNullOrUndefined(event[fields.followingID]) ||
            (!isNullOrUndefined(fields.recurrenceID) && event[fields.recurrenceID] !== event[fields.id])) &&
            this.parent.currentAction !== 'EditOccurrence' && this.parent.currentAction !== 'DeleteOccurrence') {
            parentEvent = this.parent.eventBase.getParentEvent(event);
        }
        else {
            parentEvent = this.parent.eventBase.getRecurrenceEvent(event);
        }
        if (parentEvent[fields.startTimezone] || parentEvent[fields.endTimezone]) {
            this.parent.eventBase.timezoneConvert(parentEvent);
        }
        return parentEvent;
    };
    Crud.prototype.processCrudTimezone = function (events) {
        var fields = this.parent.eventFields;
        if (events[fields.startTimezone] || events[fields.endTimezone]) {
            var startTimezone = events[fields.startTimezone] || events[fields.endTimezone];
            var endTimezone = events[fields.endTimezone] || events[fields.startTimezone];
            if (this.parent.timezone) {
                var zone = this.parent.timezone;
                events[fields.startTime] = this.timezone.convert(events[fields.startTime], startTimezone, zone);
                events[fields.endTime] = this.timezone.convert(events[fields.endTime], endTimezone, zone);
                events[fields.startTime] = this.timezone.remove(events[fields.startTime], zone);
                events[fields.endTime] = this.timezone.remove(events[fields.endTime], zone);
            }
            else {
                events[fields.startTime] = this.timezone.remove(events[fields.startTime], startTimezone);
                events[fields.endTime] = this.timezone.remove(events[fields.endTime], endTimezone);
            }
        }
        else if (this.parent.timezone) {
            events[fields.startTime] = this.timezone.remove(events[fields.startTime], this.parent.timezone);
            events[fields.endTime] = this.timezone.remove(events[fields.endTime], this.parent.timezone);
        }
    };
    Crud.prototype.excludeDateCheck = function (eventStartTime, exceptionDateList) {
        var exDate = getRecurrenceStringFromDate(eventStartTime);
        if (!isNullOrUndefined(exceptionDateList)) {
            if (exceptionDateList.indexOf(exDate) === -1) {
                exceptionDateList = !(isNullOrUndefined(exceptionDateList)) ? exceptionDateList + ',' + exDate : exDate;
            }
        }
        else {
            exceptionDateList = exDate;
        }
        return exceptionDateList;
    };
    Crud.prototype.getEditedOccurrence = function (guid) {
        var query = new Query().where('Guid', 'equal', guid);
        return new DataManager(this.parent.eventsProcessed).executeLocal(query);
    };
    Crud.prototype.getUpdatedParentRule = function (parentEvent, edited) {
        var fields = this.parent.eventFields;
        var date = new Date('' + edited[fields.startTime]);
        var startTime = new Date(date.setDate(date.getDate() + (-1)));
        return this.formatRecurrenceRule(parentEvent, startTime);
    };
    Crud.prototype.formatRecurrenceRule = function (event, startTime) {
        var fields = this.parent.eventFields;
        var untilDate = getRecurrenceStringFromDate(startTime);
        var rule = '';
        var splitRecRule = event[fields.recurrenceRule].split(';');
        if (event[fields.recurrenceRule].indexOf('UNTIL') > -1) {
            for (var _i = 0, splitRecRule_1 = splitRecRule; _i < splitRecRule_1.length; _i++) {
                var recProperty = splitRecRule_1[_i];
                if (recProperty.indexOf('COUNT') === -1 && recProperty !== '') {
                    if (recProperty.indexOf('UNTIL') > -1) {
                        recProperty = recProperty.replace(recProperty, 'UNTIL=' + untilDate);
                    }
                    rule = rule + recProperty + ';';
                }
            }
        }
        else {
            var updatedRecRule = void 0;
            var countProp = void 0;
            for (var _a = 0, splitRecRule_2 = splitRecRule; _a < splitRecRule_2.length; _a++) {
                var prop = splitRecRule_2[_a];
                countProp = prop.indexOf('COUNT') > -1 ? prop.replace(';', '') : countProp;
            }
            updatedRecRule = event[fields.recurrenceRule];
            var lastChar = updatedRecRule.slice(-1)[0];
            rule = lastChar === ';' ? updatedRecRule + 'UNTIL=' + untilDate + ';' : updatedRecRule + ';UNTIL=' + untilDate + ';';
            rule = rule.indexOf('UNTIL') > -1 ? rule.replace(countProp + ';', '') : rule;
        }
        return rule;
    };
    return Crud;
}());
export { Crud };
