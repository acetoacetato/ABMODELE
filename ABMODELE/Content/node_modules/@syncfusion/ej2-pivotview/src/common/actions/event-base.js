import { isNullOrUndefined, removeClass, addClass } from '@syncfusion/ej2-base';
import { DataManager, Query } from '@syncfusion/ej2-data';
import * as cls from '../base/css-constant';
/**
 * `EventBase` for active fields action.
 */
/** @hidden */
var EventBase = /** @class */ (function () {
    /**
     * Constructor for the dialog action.
     * @hidden
     */
    function EventBase(parent) {
        this.parent = parent;
    }
    /**
     * Updates sorting order for the selected field.
     * @method updateSorting
     * @param  {Event} args - Contains clicked element information to update dataSource.
     * @return {void}
     * @hidden
     */
    EventBase.prototype.updateSorting = function (args) {
        if (!(args.target.classList.contains(cls.FILTER_COMMON_CLASS)) &&
            !(args.target.classList.contains(cls.REMOVE_CLASS))) {
            if (this.parent.filterDialog.dialogPopUp) {
                this.parent.filterDialog.dialogPopUp.close();
            }
            var target = args.target;
            var fieldName = void 0;
            var checkisDescending = void 0;
            var isDescending = void 0;
            if (target.id) {
                fieldName = target.id;
                checkisDescending = [].slice.call(target.querySelectorAll('.' + cls.SORT_DESCEND_CLASS));
            }
            else {
                fieldName = target.parentElement.id;
                checkisDescending = [].slice.call(target.parentElement.querySelectorAll('.' + cls.SORT_DESCEND_CLASS));
            }
            if (checkisDescending.length === 0) {
                isDescending = false;
            }
            else {
                isDescending = true;
            }
            //isDescending = (target.querySelectorAll(cls.SORT_DESCEND_CLASS));
            var sortObj = this.getSortItemByName(fieldName);
            if (!isNullOrUndefined(sortObj)) {
                for (var i = 0; i < this.parent.dataSourceSettings.sortSettings.length; i++) {
                    if (this.parent.dataSourceSettings.sortSettings[i].name === fieldName) {
                        this.parent.dataSourceSettings.sortSettings.splice(i, 1);
                        break;
                    }
                }
                var newSortObj = { name: fieldName, order: isDescending ? 'Ascending' : 'Descending' };
                // let newSortObj: ISort = { name: fieldName, order: isNone ? 'Ascending' : isDescending ? 'None' : 'Descending' };
                this.parent.dataSourceSettings.sortSettings.push(newSortObj);
            }
            else {
                var newSortObj = { name: fieldName, order: isDescending ? 'Ascending' : 'Descending' };
                //let newSortObj: ISort = { name: fieldName, order: isNone ? 'Ascending' : isDescending ? 'None' : 'Descending'  };
                this.parent.dataSourceSettings.sortSettings.push(newSortObj);
            }
            this.parent.control.lastSortInfo =
                this.parent.dataSourceSettings.sortSettings[this.parent.dataSourceSettings.sortSettings.length - 1];
            isDescending ? removeClass([target], cls.SORT_DESCEND_CLASS) : addClass([target], cls.SORT_DESCEND_CLASS);
            // if (isDescending) {
            //     removeClass([target], cls.SORT_DESCEND_CLASS);
            //     addClass([target], cls.SORTING);
            // } else if (!isDescending && !isNone) {
            //     addClass([target], cls.SORT_DESCEND_CLASS);
            // } else if (isNone) {
            //     removeClass([target], cls.SORTING);
            // } else if (!isNone) {
            //     removeClass([target], cls.SORT_DESCEND_CLASS);
            //     removeClass([target], cls.SORTING);
            //    //addClass([target], cls.SORT_CLASS);
            // }
        }
    };
    /**
     * Updates sorting order for the selected field.
     * @method updateFiltering
     * @param  {Event} args - Contains clicked element information to update dataSource.
     * @return {void}
     * @hidden
     */
    EventBase.prototype.updateFiltering = function (args) {
        var target = args.target;
        var fieldName = target.parentElement.id;
        var fieldCaption = target.parentElement.textContent;
        var isInclude = false;
        var filterItems = [];
        /* tslint:disable:typedef */
        this.parent.engineModule.fieldList[fieldName].dateMember = this.parent.engineModule.fieldList[fieldName].sort === 'Ascending' ?
            (this.parent.engineModule.fieldList[fieldName].dateMember.sort(function (a, b) { return (a.actualText > b.actualText) ? 1 :
                ((b.actualText > a.actualText) ? -1 : 0); })) :
            this.parent.engineModule.fieldList[fieldName].sort === 'Descending' ?
                (this.parent.engineModule.fieldList[fieldName].dateMember.sort(function (a, b) { return (a.actualText < b.actualText) ? 1 :
                    ((b.actualText < a.actualText) ? -1 : 0); })) :
                this.parent.engineModule.fieldList[fieldName].dateMember;
        /* tslint:enable:typedef */
        var filterObj = this.getFilterItemByName(fieldName);
        if (!isNullOrUndefined(filterObj)) {
            isInclude = filterObj.type === 'Include' ? true : false;
            filterItems = filterObj.items ? filterObj.items : [];
        }
        var treeData = this.getTreeData(isInclude, this.parent.engineModule.fieldList[fieldName].dateMember, filterItems, fieldName);
        if (this.parent.filterDialog.dialogPopUp) {
            this.parent.filterDialog.dialogPopUp.close();
        }
        var popupTarget;
        popupTarget = this.parent.moduleName !== 'pivotfieldlist' ?
            popupTarget = this.parent.element : popupTarget = document.getElementById(this.parent.parentID + '_Wrapper');
        this.parent.filterDialog.createFilterDialog(treeData, fieldName, fieldCaption, popupTarget);
    };
    /**
     * Gets sort object for the given field name from the dataSource.
     * @method getSortItemByName
     * @param  {string} fieldName - Gets sort settings for the given field name.
     * @return {Sort}
     * @hidden
     */
    EventBase.prototype.getSortItemByName = function (fieldName) {
        var sortObjects = this.parent.dataSourceSettings.sortSettings;
        return new DataManager({ json: sortObjects }).executeLocal(new Query().where('name', 'equal', fieldName))[0];
    };
    /**
     * Gets filter object for the given field name from the dataSource.
     * @method getFilterItemByName
     * @param  {string} fieldName - Gets filter settings for the given field name.
     * @return {Sort}
     * @hidden
     */
    EventBase.prototype.getFilterItemByName = function (fieldName) {
        var filterObjects = this.parent.dataSourceSettings.filterSettings;
        return new DataManager({ json: filterObjects }).executeLocal(new Query().where('name', 'equal', fieldName))[0];
    };
    /**
     * Gets filter object for the given field name from the dataSource.
     * @method getFieldByName
     * @param  {string} fieldName - Gets filter settings for the given field name.
     * @return {Sort}
     * @hidden
     */
    EventBase.prototype.getFieldByName = function (fieldName, fields) {
        return new DataManager({ json: fields }).executeLocal(new Query().where('name', 'equal', fieldName))[0];
    };
    /**
     * Gets format object for the given field name from the dataSource.
     * @method getFilterItemByName
     * @param  {string} fieldName - Gets format settings for the given field name.
     * @return {IFormatSettings}
     * @hidden
     */
    EventBase.prototype.getFormatItemByName = function (fieldName) {
        var formatObjects = this.parent.dataSourceSettings.formatSettings;
        return new DataManager({ json: formatObjects }).executeLocal(new Query().where('name', 'equal', fieldName))[0];
    };
    /**
     * show tree nodes using search text.
     * @hidden
     */
    EventBase.prototype.searchTreeNodes = function (args, treeObj, isFieldCollection) {
        if (isFieldCollection) {
            var searchList = [];
            var nonSearchList = [];
            var list = [].slice.call(treeObj.element.querySelectorAll('li'));
            for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {
                var element = list_1[_i];
                if ((element.querySelector('.e-list-text').textContent.toLowerCase()).indexOf(args.value.toLowerCase()) > -1) {
                    searchList.push(element);
                }
                else {
                    nonSearchList.push(element);
                }
            }
            treeObj.enableNodes(searchList);
            treeObj.disableNodes(nonSearchList);
        }
        else {
            var searchList = [];
            this.parent.searchTreeItems = [];
            var memberCount = 0;
            memberCount = 1;
            for (var _a = 0, _b = this.parent.currentTreeItems; _a < _b.length; _a++) {
                var item = _b[_a];
                if (item.name.toLowerCase().indexOf(args.value.toLowerCase()) > -1) {
                    this.parent.searchTreeItems.push(item);
                    if (memberCount <= this.parent.control.maxNodeLimitInMemberEditor) {
                        searchList.push(item);
                    }
                    memberCount++;
                }
            }
            memberCount--;
            if (memberCount > this.parent.control.maxNodeLimitInMemberEditor) {
                this.parent.editorLabelElement.innerText = (memberCount - this.parent.control.maxNodeLimitInMemberEditor) +
                    this.parent.control.localeObj.getConstant('editorDataLimitMsg');
                this.parent.filterDialog.dialogPopUp.height = (this.parent.filterDialog.allowExcelLikeFilter ? '440px' : '400px');
                this.parent.isDataOverflow = true;
            }
            else {
                this.parent.editorLabelElement.innerText = '';
                this.parent.filterDialog.dialogPopUp.height = (this.parent.filterDialog.allowExcelLikeFilter ? '400px' : '350px');
                this.parent.isDataOverflow = false;
            }
            this.parent.isDataOverflow = (memberCount > this.parent.control.maxNodeLimitInMemberEditor);
            this.parent.editorLabelElement.parentElement.style.display = this.parent.isDataOverflow ? 'inline-block' : 'none';
            treeObj.fields = { dataSource: searchList, id: 'id', text: 'name', isChecked: 'checkedStatus' };
            treeObj.dataBind();
        }
    };
    EventBase.prototype.getTreeData = function (isInclude, members, filterItems, fieldName) {
        this.parent.currentTreeItems = [];
        this.parent.searchTreeItems = [];
        this.parent.currentTreeItemsPos = {};
        this.parent.savedTreeFilterPos = {};
        this.parent.isDateField = this.parent.engineModule.formatFields[fieldName] &&
            ((['date', 'dateTime', 'time']).indexOf(this.parent.engineModule.formatFields[fieldName].type) > -1);
        var list = [];
        var memberCount = 1;
        var filterObj = {};
        for (var _i = 0, filterItems_1 = filterItems; _i < filterItems_1.length; _i++) {
            var item = filterItems_1[_i];
            filterObj[item] = item;
        }
        for (var _a = 0, members_1 = members; _a < members_1.length; _a++) {
            var member = members_1[_a];
            var memberName = this.parent.isDateField ? member.formattedText : member.actualText.toString();
            var obj = {
                id: member.actualText.toString(),
                name: memberName,
                checkedStatus: isInclude ? false : true
            };
            if (filterObj[memberName] !== undefined) {
                obj.checkedStatus = isInclude ? true : false;
            }
            if (memberCount <= this.parent.control.maxNodeLimitInMemberEditor) {
                list.push(obj);
            }
            if (!obj.checkedStatus) {
                this.parent.savedTreeFilterPos[memberCount - 1] = memberName;
            }
            this.parent.currentTreeItems.push(obj);
            this.parent.searchTreeItems.push(obj);
            this.parent.currentTreeItemsPos[member.actualText] = memberCount - 1;
            memberCount++;
        }
        this.parent.isDataOverflow = ((memberCount - 1) > this.parent.control.maxNodeLimitInMemberEditor);
        return list;
    };
    return EventBase;
}());
export { EventBase };
