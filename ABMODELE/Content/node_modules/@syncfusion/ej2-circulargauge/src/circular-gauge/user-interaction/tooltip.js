import { Tooltip } from '@syncfusion/ej2-svg-base';
import { getPointer, Rect, getMousePosition, getElementSize } from '../utils/helper';
import { getAngleFromValue, getLabelFormat, getLocationFromAngle } from '../utils/helper';
import { Browser, createElement, remove, isNullOrUndefined, updateBlazorTemplate, resetBlazorTemplate } from '@syncfusion/ej2-base';
import { tooltipRender } from '../model/constants';
/**
 * Tooltip Module handles the tooltip of the circular gauge
 */
var GaugeTooltip = /** @class */ (function () {
    /**
     * Constructor for Tooltip module.
     * @private.
     */
    function GaugeTooltip(gauge) {
        this.gauge = gauge;
        this.tooltipId = this.gauge.element.id + '_CircularGauge_Tooltip';
        this.tooltip = gauge.tooltip;
        this.textStyle = this.tooltip.textStyle;
        this.borderStyle = this.tooltip.border;
        this.addEventListener();
    }
    /**
     * Method to render the tooltip for circular gauge.
     */
    /* tslint:disable:no-string-literal */
    /* tslint:disable:max-func-body-length */
    GaugeTooltip.prototype.renderTooltip = function (e) {
        var _this = this;
        var pageX;
        var pageY;
        var target;
        var touchArg;
        var location;
        var samePointerEle = false;
        if (e.type.indexOf('touch') !== -1) {
            touchArg = e;
            target = touchArg.target;
            pageX = touchArg.changedTouches[0].pageX;
            pageY = touchArg.changedTouches[0].pageY;
        }
        else {
            target = e.target;
            pageX = e.pageX;
            pageY = e.pageY;
        }
        if (target.id.indexOf('_Pointer_') >= 0) {
            if (this.pointerEle !== null) {
                samePointerEle = (this.pointerEle === target);
            }
            var svgRect_1 = this.gauge.svgObject.getBoundingClientRect();
            var elementRect = this.gauge.element.getBoundingClientRect();
            var axisRect_1 = document.getElementById(this.gauge.element.id + '_AxesCollection').getBoundingClientRect();
            var rect_1 = new Rect(Math.abs(elementRect.left - svgRect_1.left), Math.abs(elementRect.top - svgRect_1.top), svgRect_1.width, svgRect_1.height);
            var currentPointer = getPointer(target.id, this.gauge);
            this.currentAxis = this.gauge.axes[currentPointer.axisIndex];
            this.currentPointer = (this.currentAxis.pointers)[currentPointer.pointerIndex];
            var angle_1 = getAngleFromValue(this.currentPointer.currentValue, this.currentAxis.visibleRange.max, this.currentAxis.visibleRange.min, this.currentAxis.startAngle, this.currentAxis.endAngle, this.currentAxis.direction === 'ClockWise') % 360;
            var tooltipFormat = this.gauge.tooltip.format || this.currentAxis.labelStyle.format;
            var customLabelFormat = tooltipFormat && tooltipFormat.match('{value}') !== null;
            var format = this.gauge.intl.getNumberFormat({
                format: getLabelFormat(tooltipFormat), useGrouping: this.gauge.useGroupingSeparator
            });
            if (document.getElementById(this.tooltipId)) {
                this.tooltipEle = document.getElementById(this.tooltipId);
            }
            else {
                this.tooltipEle = createElement('div', {
                    id: this.tooltipId,
                    className: 'EJ2-CircularGauge-Tooltip',
                    styles: 'position: absolute;pointer-events:none;'
                });
                document.getElementById(this.gauge.element.id + '_Secondary_Element').appendChild(this.tooltipEle);
            }
            var roundValue = void 0;
            roundValue = this.currentAxis.roundingPlaces ?
                parseFloat(this.currentPointer.currentValue.toFixed(this.currentAxis.roundingPlaces)) :
                this.currentPointer.currentValue;
            var content_1 = customLabelFormat ?
                tooltipFormat.replace(new RegExp('{value}', 'g'), format(roundValue)) :
                format(roundValue);
            location = getLocationFromAngle(angle_1, this.currentAxis.currentRadius, this.gauge.midPoint);
            location.x = (this.tooltip.template && ((angle_1 >= 150 && angle_1 <= 250) || (angle_1 >= 330 && angle_1 <= 360) ||
                (angle_1 >= 0 && angle_1 <= 45))) ? (location.x + 10) : location.x;
            var tooltipArgs_1 = {
                name: tooltipRender, cancel: false, content: content_1, location: location, axis: this.currentAxis,
                tooltip: this.tooltip, pointer: this.currentPointer, event: e, gauge: this.gauge,
                appendInBodyTag: false
            };
            this.gauge.trigger(tooltipRender, tooltipArgs_1, function (observedArgs) {
                var template = tooltipArgs_1.tooltip.template;
                if (template !== null && template.length === 1) {
                    template = template[template[0]];
                }
                if (!_this.tooltip.showAtMousePosition) {
                    if (template) {
                        var elementSize = getElementSize(template, _this.gauge, _this.tooltipEle);
                        _this.tooltipRect = Math.abs(axisRect_1.left - svgRect_1.left) > elementSize.width ?
                            _this.findPosition(rect_1, angle_1, content_1, tooltipArgs_1.location) : rect_1;
                    }
                    else {
                        _this.findPosition(rect_1, angle_1, content_1, tooltipArgs_1.location);
                    }
                }
                else {
                    tooltipArgs_1.location = getMousePosition(pageX, pageY, _this.gauge.svgObject);
                    _this.tooltipRect = rect_1;
                }
                if (!tooltipArgs_1.cancel && !samePointerEle) {
                    tooltipArgs_1.tooltip.textStyle.color = tooltipArgs_1.tooltip.textStyle.color || _this.gauge.themeStyle.tooltipFontColor;
                    tooltipArgs_1.tooltip.textStyle.fontFamily = _this.gauge.themeStyle.fontFamily || tooltipArgs_1.tooltip.textStyle.fontFamily;
                    tooltipArgs_1.tooltip.textStyle.opacity =
                        _this.gauge.themeStyle.tooltipTextOpacity || tooltipArgs_1.tooltip.textStyle.opacity;
                    _this.svgTooltip = new Tooltip({
                        enable: true,
                        data: { value: tooltipArgs_1.content },
                        template: template,
                        enableAnimation: tooltipArgs_1.tooltip.enableAnimation,
                        content: [tooltipArgs_1.content],
                        location: tooltipArgs_1.location,
                        inverted: _this.arrowInverted,
                        areaBounds: _this.tooltipRect,
                        fill: tooltipArgs_1.tooltip.fill || _this.gauge.themeStyle.tooltipFillColor,
                        textStyle: tooltipArgs_1.tooltip.textStyle,
                        availableSize: _this.gauge.availableSize,
                        border: tooltipArgs_1.tooltip.border
                    });
                    _this.svgTooltip.opacity = _this.gauge.themeStyle.tooltipFillOpacity || _this.svgTooltip.opacity;
                    _this.svgTooltip.appendTo(_this.tooltipEle);
                    if (_this.gauge.tooltip.template) {
                        updateBlazorTemplate(_this.gauge.element.id + 'Template', 'Template');
                    }
                    if (template && Math.abs(pageY - _this.tooltipEle.getBoundingClientRect().top) <= 0) {
                        _this.tooltipEle.style.top = (parseFloat(_this.tooltipEle.style.top) + 20) + 'px';
                    }
                    if (tooltipArgs_1.appendInBodyTag) {
                        var bodyToolElement = document.getElementsByClassName('EJ2-CircularGauge-Tooltip e-control e-tooltip');
                        if (!isNullOrUndefined(bodyToolElement)) {
                            _this.removeTooltip();
                        }
                        document.body.appendChild(_this.tooltipEle);
                        _this.tooltipEle.style.zIndex = '100000000001';
                        var bounds = _this.tooltipEle.getBoundingClientRect();
                        if (pageX + bounds['width'] <= window.innerWidth && bounds['x'] <= 0) {
                            _this.tooltipEle.style.left = pageX + 20 + 'px';
                            _this.tooltipEle.style.top = bounds['top'] + 20 + 'px';
                        }
                        else if (bounds['x'] <= 0 && pageX + bounds['width'] >= window.innerWidth) {
                            _this.tooltipEle.style.left = pageX - bounds['width'] + 20 + 'px';
                            _this.tooltipEle.style.top = bounds['top'] + 20 + 'px';
                        }
                    }
                }
            });
        }
        else {
            this.removeTooltip();
            if (this.gauge.tooltip.template) {
                resetBlazorTemplate(this.gauge.element.id + 'Template', 'Template');
            }
        }
    };
    /**
     * Method to find the position of the tooltip anchor for circular gauge.
     */
    GaugeTooltip.prototype.findPosition = function (rect, angle, text, location) {
        var addLeft;
        var addTop;
        var addHeight;
        var addWidth;
        switch (true) {
            case (angle >= 0 && angle < 45):
                this.arrowInverted = true;
                addLeft = (angle >= 15 && angle <= 30) ? location.y : 0;
                this.tooltipRect = new Rect(rect.x, rect.y + addTop, rect.width, rect.height);
                this.tooltipPosition = 'RightBottom';
                break;
            case (angle >= 45 && angle < 90):
                this.arrowInverted = false;
                this.tooltipRect = new Rect(rect.x, rect.y + location.y, rect.width, rect.height);
                this.tooltipPosition = 'BottomRight';
                break;
            case (angle >= 90 && angle < 135):
                this.arrowInverted = false;
                this.tooltipRect = new Rect(rect.x, rect.y + location.y, rect.width, rect.height);
                this.tooltipPosition = 'BottomLeft';
                break;
            case (angle >= 135 && angle < 180):
                this.arrowInverted = true;
                addTop = (angle >= 150 && angle <= 160) ? location.y : 0;
                this.tooltipRect = new Rect(rect.x - rect.width, rect.y + addTop, rect.width, rect.height);
                this.tooltipPosition = 'LeftBottom';
                break;
            case (angle >= 180 && angle < 225):
                this.arrowInverted = true;
                addHeight = (angle >= 200 && angle <= 225) ? Math.abs(rect.y - location.y) : rect.height;
                this.tooltipRect = new Rect(rect.x - rect.width, rect.y, rect.width, addHeight);
                this.tooltipPosition = 'LeftTop';
                break;
            case (angle >= 225 && angle < 270):
                this.arrowInverted = false;
                addWidth = (angle >= 250 && angle <= 290) ? rect.width : Math.abs(rect.x - location.x);
                this.tooltipRect = new Rect(rect.x, rect.y, addWidth, rect.height);
                this.tooltipPosition = 'TopLeft';
                break;
            case (angle >= 270 && angle < 315):
                this.arrowInverted = false;
                addLeft = (angle >= 270 && angle > 290) ? location.x : 0;
                this.tooltipRect = new Rect(rect.x + addLeft, rect.y, rect.width, rect.height);
                this.tooltipPosition = 'TopRight';
                break;
            case (angle >= 315 && angle <= 360):
                this.arrowInverted = true;
                addHeight = (angle >= 315 && angle <= 340) ? Math.abs(rect.y - location.y) : rect.height;
                this.tooltipRect = new Rect(rect.x, rect.y, rect.width, addHeight);
                this.tooltipPosition = 'RightTop';
                break;
        }
        return this.tooltipRect;
    };
    GaugeTooltip.prototype.removeTooltip = function () {
        if (document.getElementsByClassName('EJ2-CircularGauge-Tooltip').length > 0) {
            var tooltip = document.getElementsByClassName('EJ2-CircularGauge-Tooltip')[0];
            if (tooltip) {
                remove(tooltip);
            }
            this.pointerEle = null;
        }
    };
    GaugeTooltip.prototype.mouseUpHandler = function (e) {
        this.renderTooltip(e);
        clearTimeout(this.clearTimeout);
        this.clearTimeout = setTimeout(this.removeTooltip.bind(this), 2000);
    };
    /**
     * To bind events for tooltip module
     */
    GaugeTooltip.prototype.addEventListener = function () {
        if (this.gauge.isDestroyed) {
            return;
        }
        this.gauge.on(Browser.touchMoveEvent, this.renderTooltip, this);
        this.gauge.on(Browser.touchEndEvent, this.mouseUpHandler, this);
    };
    /**
     * To unbind events for tooltip module
     */
    GaugeTooltip.prototype.removeEventListener = function () {
        if (this.gauge.isDestroyed) {
            return;
        }
        this.gauge.off(Browser.touchMoveEvent, this.renderTooltip);
        this.gauge.off(Browser.touchEndEvent, this.mouseUpHandler);
    };
    /**
     * Get module name.
     */
    GaugeTooltip.prototype.getModuleName = function () {
        // Returns te module name
        return 'Tooltip';
    };
    /**
     * To destroy the tooltip.
     * @return {void}
     * @private
     */
    GaugeTooltip.prototype.destroy = function (gauge) {
        // Destroy method performed here
        this.removeEventListener();
    };
    return GaugeTooltip;
}());
export { GaugeTooltip };
